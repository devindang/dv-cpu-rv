#### 1. Given two numbers, add them and store into memory.

##### C code

```c
#include "stdio.h"
int main() {
	int a = 14;
	int b = 15;
	int c;
	c = a + b;
	return 0;
}
```


##### Assembly code

```assembly
addi x2 x0 14;	//0//	00000000111000000000000100010011
addi x3 x0 15;	//4//	00000000111100000000000110010011
add  x1 x2 x3;	//8//	00000000001100010000000010110011
sd   x1 16(x2);	//12//	00000000000100010011010000100011
```

#### 2. Given a non-zero natural number N, calculate the sum of natural numbers less than N.

##### C code

```c
#include "stdio.h"
int main() {
	int N = 10;
	int sum = 0;
	for(int i=1; i<N; i++){
		sum = sum+i;
	}
	return 0;
}
```

##### Assembly code

```assembly
addi x1 x0 10;	//0//	00000000101000000000000010010011
addi x2 x0 1;	//4//	00000000000100000000000100010011
addi x3 x0 0;	//8//	00000000000000000000000110010011
add  x3 x2 x3;	//12//	00000000001100010000000110110011
addi x2 x2 1;	//16//	00000000000100010000000100010011
blt  x2 x1 A12;	//20//	11111110000100010100110011100011
sd   x3 8(x1);	//24//	00000000001100001011010000100011
```

> In RISC-V, the offset of ***beq*** represent the number of halfwords between the branch and the branch target, which is singed.

#### 3. Test RV32I, cover as much as possible.

##### C code

```c
int a = 10000;			// 10000
int b = 1808;			// 1808
int c = 1;				// 1
int d = b+c;			// 1809
int e = d-c;			// 1808
int f = e.sll(c);		// 3616
int g = f.srl(c);		// 1808
int h = (g<f)?;			// 1
int i = x0-g;			// -1808
int j = i.sra(c);		// -904
int k = 156;			// 156
int l = j xor k;		// -796
int m = k or x0;		// 156
int n = i and k;		// 144
```

###### Assembly code

```assembly
lui  x1 2;			//0//	00000000000000000010000010110111
addi x1 x1 1808;	//4//	01110001000000001000000010010011
addi x2 x0 1808;	//8//	01110001000000000000000100010011
addi x3 x0 1;		//12//	00000000000100000000000110010011
add  x4 x2 x3;		//16//	00000000001100010000001000110011
sub  x5 x4 x3;		//20//	01000000001100100000001010110011
sll  x6 x5 x3;		//24//	00000000001100101001001100110011
srl  x7 x6 x3;		//28//	00000000001100110101001110110011
slt	 x8 x7 x6;		//32//	00000000011000111010010000110011
sub  x9 x0 x7;		//36//	01000000011100000000010010110011
sra  x10 x9 x3;		//40//	01000000001101001101010100110011
addi x11 x0 156;	//44//  00001001110000000000010110010011
xor  x12 x10 x11;	//48//	00000000101101010100011000110011
or	 x13 x11 x0;	//52//	00000000000001011110011010110011
and  x14 x11 x9;	//56//	00000000100101011111011100110011
sd   x1 0(x0);		//60//	00000000000100000011000000100011
sd   x2 1(x0);		//64//	00000000001000000011000010100011
sd   x3 2(x0);		//68//	00000000001100000011000100100011
sd   x4 3(x0);		//72//	00000000010000000011000110100011
sd   x5 4(x0);		//76//	00000000010100000011001000100011
sd   x6 5(x0);		//80//	00000000011000000011001010100011
sd   x7 6(x0);		//84//	00000000011100000011001100100011
sd   x8 7(x0);		//88//	00000000100000000011001110100011
sd   x9 8(x0);		//92//	00000000100100000011010000100011
sd   x10 9(x0);		//96//	00000000101000000011010010100011
sd   x11 10(x0);	//100//	00000000101100000011010100100011
sd   x12 11(x0);	//104//	00000000110000000011010110100011
sd   x13 12(x0);	//108//	00000000110100000011011000100011
sd   x14 13(x0);	//112//	00000000111000000011011010100011
```

