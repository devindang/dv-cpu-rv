#### 1. Given two numbers, add them and store into memory.

##### C code

```c
#include "stdio.h"
int main() {
	int a = 14;
	int b = 15;
	int c;
	c = a + b;
	return 0;
}
```


##### Assembly code

```assembly
addi x2 x0 14;	//0//	00000000111000000000000100010011
addi x3 x0 15;	//4//	00000000111100000000000110010011
add  x1 x2 x3;	//8//	00000000001100010000000010110011
sd   x1 16(x2);	//12//	00000000000100010011010000100011
```

#### 2. Given a non-zero natural number N, calculate the sum of natural numbers less than N.

##### C code

```c
#include "stdio.h"
int main() {
	int N = 10;
	int sum = 0;
	for(int i=1; i<N; i++){
		sum = sum+i;
	}
	return 0;
}
```

##### Assembly code

```assembly
addi x1 x0 10;	//0//	00000000101000000000000010010011
addi x2 x0 1;	//4//	00000000000100000000000100010011
addi x3 x0 0;	//8//	00000000000000000000000110010011
add  x3 x2 x3;	//12//	00000000001100010000000110110011
addi x2 x2 1;	//16//	00000000000100010000000100010011
blt  x2 x1 A12;	//20//	11111110000100010100110011100011
sd   x3 8(x1);	//24//	00000000001100001011010000100011
```

> In RISC-V, the offset of ***beq*** represent the number of halfwords between the branch and the branch target, which is singed.

#### 3. Test RV32I, cover as much as possible.

##### C code

```c
int a = 10000;			// 10000
int b = 1808;			// 1808
int c = 1;				// 1
int d = b+c;			// 1809
int e = d-c;			// 1808
int f = e.sll(c);		// 3616
int g = f.srl(c);		// 1808
int h = (g<f)?;			// 1
int i = x0-g;			// -1808
int j = i.sra(c);		// -904
int k = 156;			// 156
int l = j xor k;		// -796
int m = k or x0;		// 156
int n = i and k;		// 144
// additional test code not shown here
```

###### Assembly code

```assembly
lui  x1 2;			//0//	0000000 00000 00000 010 00001 0110111
addi x1 x1 1808;	//4//	0111000 10000 00001 000 00001 0010011
addi x2 x0 1808;	//8//	0111000 10000 00000 000 00010 0010011
addi x3 x0 1;		//12//	0000000 00001 00000 000 00011 0010011
add  x4 x2 x3;		//16//	0000000 00011 00010 000 00100 0110011
sub  x5 x4 x3;		//20//	0100000 00011 00100 000 00101 0110011
sll  x6 x5 x3;		//24//	0000000 00011 00101 001 00110 0110011
srl  x7 x6 x3;		//28//	0000000 00011 00110 101 00111 0110011
slt	 x8 x7 x6;		//32//	0000000 00110 00111 010 01000 0110011
sub  x9 x0 x7;		//36//	0100000 00111 00000 000 01001 0110011
sra  x10 x9 x3;		//40//	0100000 00011 01001 101 01010 0110011
addi x11 x0 156;	//44//  0000100 11100 00000 000 01011 0010011
xor  x12 x10 x11;	//48//	0000000 01011 01010 100 01100 0110011
or	 x13 x11 x0;	//52//	0000000 00000 01011 110 01101 0110011
and  x14 x11 x9;	//56//	0000000 01001 01011 111 01110 0110011
sd   x1 0(x0);		//60//	0000000 00001 00000 011 00000 0100011
sd   x2 8(x0);		//64//	0000000 00010 00000 011 01000 0100011
sd   x3 16(x0);		//68//	0000000 00011 00000 011 10000 0100011
sd   x4 24(x0);		//72//	0000000 00100 00000 011 11000 0100011
sd   x5 32(x0);		//76//	0000001 00101 00000 011 00000 0100011
sd   x6 40(x0);		//80//	0000001 00110 00000 011 01000 0100011
sd   x7 48(x0);		//84//	0000001 00111 00000 011 10000 0100011
sd   x8 56(x0);		//88//	0000001 01000 00000 011 11000 0100011
sd   x9 64(x0);		//92//	0000010 01001 00000 011 00000 0100011
sd   x10 72(x0);	//96//	0000010 01010 00000 011 01000 0100011
sd   x11 80(x0);	//100//	0000010 01011 00000 011 10000 0100011
sd   x12 88(x0);	//104//	0000010 01100 00000 011 11000 0100011
sd   x13 96(x0);	//108//	0000011 01101 00000 011 00000 0100011
sd   x14 104(x0);	//112//	0000011 01110 00000 011 01000 0100011
sb	 x9  113(x0);	//116// 0000011 01001 00000 000 10001 0100011
sh	 x9  122(x0);	//120//	0000011 01001 00000 001 11010 0100011
sw	 x9  132(x0);	//124//	0000100 01001 00000 010 00100 0100011
sd	 x9  136(x0);	//128//	0000100 01001 00000 011 01000 0100011
lb	 x15 113(x0);	//132// 000001110001 00000 000 01111 0000011
lh	 x16 122(x0);	//136//	000001111010 00000 001 10000 0000011
lw	 x17 132(x0);	//140//	000010000100 00000 010 10001 0000011
lbu	 x18 113(x0);	//144//	000001110001 00000 100 10010 0000011
lhu	 x19 122(x0);	//148//	000001111010 00000 101 10011 0000011
lwu	 x20 132(x0);	//152//	000010000100 00000 110 10100 0000011
ld	 x21 136(x0);	//156// 000010001000 00000 011 10101 0000011
 
```

#### 4. Test remaining RV32I, cover as much as possible.

##### pseudo code

```c
x1 = 0 & 11;		// 11
x2 = x1 | 13;		// 9
x3 = x2 ^ 10;		// 3
x4 = (x3 < 8);		// true
x5 = (x3 < -1);		// true
x6 = x4 << 2;		// 4
x7 = x6 >> 1; 		// 2
x8 = x7 >>> 1;		// 1
x9 = 0 - x6;		// -4
x10 = 0 - x7;		// -2
if(x8==x7) null; else x31 = x31 + 1;
if(x8!=x7) null; else x31 = x31 + 1;
if(x9<x10) null; else x31 = x31 + 1;
if(x7>=x8) null; else x31 = x31 + 1;
if(x10<x9) null; else x31 = x31 + 1;	// x31 will be 1, because -2 > -4
if(x6>=x8) null; else x31 = x31 + 1;
x30 = PC+4*4096;	// 16384+88
PC* = PC+4*2; x29=PC;	// 100
x20 = x20 + 1;		// x20 won't change
x21 = x21 + 1;		// increase repeatly
PC* = x29+0;		// jump to 0(x29)
```

##### Assembly code

```assembly
ori  x1 x0 11;	//0//	000000001011 00000 110 00001 0010011
andi x2 x1 13;	//4//	000000001101 00001 111 00010 0010011
xori x3 x2 10;	//8//	000000001010 00010 100 00011 0010011
slti x4 x3 8;	//12//	000000001000 00011 010 00100 0010011
sltiu x5 x3 -1;	//16//	111111111111 00011 011 00101 0010011
slli x6 x4 2;	//20//	0000000 00010 00100 001 00110 0010011
srli x7 x6 1;	//24//	0000000 00001 00110 101 00111 0010011
srai x8 x7 1;	//28//	0100000 00001 00111 101 01000 0010011
sub  x9 x0 x6;	//32//	0100000 00110 00000 000 01001 0110011
sub  x10 x0 x7;	//36//	0100000 00111 00000 000 01010 0110011
beq  x8 x4 A+4;	//40//  0000000 00100 01000 000 01000 1100011
addi x31 x0 1;	//44//	000000000001 00000 000 11111 0010011
bne	 x8 x7 A+4;	//48//  0000000 00111 01000 001 01000 1100011
addi x31 x31 1;	//52//	000000000001 11111 000 11111 0010011
blt	 x9 x10 A+4;//56//  0000000 01010 01001 100 01000 1100011
addi x31 x31 1;	//60//	000000000001 11111 000 11111 0010011
bge  x7 x8 A+4;	//64//  0000000 01000 00111 101 01000 1100011
addi x31 x31 1;	//68//	000000000001 11111 000 11111 0010011
bltu x10 x9 A+4;//72//  0000000 01001 01010 110 01000 1100011
addi x31 x31 1;	//76//	000000000001 11111 000 11111 0010011
bgeu x6 x8 A+4;	//80//  0000000 01000 00110 111 01000 1100011
addi x31 x31 1;	//84//	000000000001 11111 000 11111 0010011
auipc x30 4;	//88//  0000000 00000 00000 100 11110 0010111
jal  x29 4;		//92//  0000000 01000 00000 000 11101 1101111
addi x20 x20 1;	//96//  000000000001 10100 000 10100 0010011
addi x21 x21 1;	//100// 000000000001 10101 000 10101 0010011
jalr x0 0(x29);	//104// 000000000000 11101 000 00000 1100111
```



